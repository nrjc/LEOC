from typing import List, Tuple
import math
import gin
import numpy as np
import pandas as pd
import csv
from matplotlib import pyplot as plt
from gym import logger
import tensorflow as tf
from tf_agents.trajectories.trajectory import Trajectory
from dao.controller_utils import calculate_ratio

plt.style.use('seaborn-darkgrid')


# This class plots different graphs for a single epoch from a list of trajectories generated by eval
@gin.configurable
class EpochPlotter(object):
    def __init__(self, trajectories: List[Trajectory]):
        self.trajectories = trajectories
        self.observations = [x.observation for x in trajectories]
        self.rewards = [x.reward for x in trajectories]
        self.actions = [x.action for x in trajectories]
        self.ratio = [x.policy_info for x in trajectories]
        # self.timesteps = len(self.observations)
        self.timesteps = 100
        plt.style.use('seaborn-darkgrid')

    def traj2theta(self, obs_idx: int = 0) -> np.ndarray:
        """
        Input:
            trajectories: trajectories from eval
            obs_idx: index of the observation corresponding to cosine
        Output:
            np.ndarray of states
        """
        observations = [i.numpy()[0] for i in self.observations]
        observations = np.array(observations)
        cos_theta = observations[:self.timesteps, obs_idx]
        theta = tf.math.acos(cos_theta)
        return theta

    def traj2info(self) -> np.ndarray:
        """
        Input:
            trajectories: trajectories from eval
        Output:
            np.ndarray of info/controller ratios
        """
        ratios = [i.numpy()[0] for i in self.ratio]
        ratios = np.array(ratios[:self.timesteps])
        return ratios

    def traj2metrics(self, target: List[float], stability_bound: float) \
            -> Tuple[float, int, int]:
        """
        Input:
            trajectories: trajectories from eval
        Output:
            np.ndarray of the control theory metrics
        """
        traj = np.array(self.trajectories)
        peak_overshot = max(traj) - target
        rising_time = traj.index(max(traj))

        traj_reverse = traj[::-1]
        upper_stability_bound, lower_stability_bound = target + stability_bound, target - stability_bound
        settling_time = np.argmax(lower_stability_bound < traj_reverse < upper_stability_bound)
        settling_time = len(traj_reverse) - settling_time

        return (peak_overshot, rising_time, settling_time)

    def plot_state_cum_ratio(self):

        thetas = self.traj2theta()
        ratios = self.traj2info()

        fig, ax1 = plt.subplots(figsize=(6, 4))

        # Plot theta
        ln1 = ax1.plot(np.arange(self.timesteps), thetas, color='royalblue', label='\u03B8')
        ax1.set_xlabel('Timesteps')
        ax1.legend()
        ax1.set_title(f'\u03B8 and Controller Ratio')

        # Plot linear ratio
        ax2 = ax1.twinx()
        ln2 = ax2.plot(np.arange(self.timesteps), ratios, color='darkorange', label='Controller Ratio')

        # Set legend and format
        lns = ln1 + ln2
        labs = [l.get_label() for l in lns]
        ax1.legend(lns, labs)
        ax2.grid(False)
        fig.show()

    def plot_metrics(self):
        pass


# This class plots learning curves for the entire training session from a list of np.arrays
class EntireTrainingPlotter(object):
    def __init__(self, rewards: List[np.ndarray]):
        self.rewards = rewards

    def plot_rewards(self):
        pass


@gin.configurable
def pilco_plotter(predict_m, predict_s, realise, S, target):
    # Plot theta and linear ratio from PILCO

    # Plotting internal states of pilco variables
    # predict_cos_m, predict_sin_m = np.array([x[0] for x in predict_m]), np.array([x[1] for x in predict_m])
    # predict_cos_s, predict_sin_s = np.array([x[0] for x in predict_s]), np.array([x[1] for x in predict_s])
    # predict_theta = trig2theta(predict_cos_m, predict_sin_m)

    realise_cos, realise_sin = np.array([x[0] for x in realise]), np.array([x[1] for x in realise])
    realise_theta = tf.math.acos(realise_cos)

    timesteps = len(realise)

    state_dim = len(target)
    ratio = np.array([calculate_ratio(x[:state_dim], target, S) for x in realise])

    fig, ax1 = plt.subplots(figsize=(6, 4))

    # Plot theta
    ln1 = ax1.plot(np.arange(timesteps), realise_theta, color='royalblue', label='\u03B8')
    ax1.set_xlabel('Timesteps')
    ax1.legend()
    ax1.set_title(f'\u03B8 and Controller Ratio')

    # Plot linear ratio
    ax2 = ax1.twinx()
    ln2 = ax2.plot(np.arange(timesteps), ratio, color='darkorange', label='Controller Ratio')

    lns = ln1 + ln2
    labs = [l.get_label() for l in lns]
    ax1.legend(lns, labs)
    ax2.grid(False)
    fig.show()


def plot_single_rollout_cycle(state_mean: List[np.ndarray], state_var: List[np.ndarray],
                              rollout: List[List[np.ndarray]], rollout_actions: List[np.ndarray],
                              all_rewards: List[np.ndarray], all_S: List[np.ndarray], rollout_ratio: List[np.ndarray],
                              internal_state_dim_num: int, action_dim_num: int,
                              time_steps: int, rollout_num: int, env='swing up', write_to_csv=False):
    """

    Args:
        state_mean: T x N. A list (length T) of numpy array of dimension (N), denoting the predicted means at each time step.
        state_var: T x N. A list (length T) of numpy array of dimension (N), denoting the variance at each time step.
        rollout: S x T x N. A list (length S) of list (length T) of numpy array of dimension (N), denoting the observed parameter state.
        rollout_action: T x M. A list (length T) of numpy array of dimension (M), denoting the actions taken by rollout controller.
        all_rewards: 1 x N. A list (length N) of tensors, denoting the reward at the end of all previous rollouts.
        all_S: N x lambda_dim.  A list (length N) of tensors of dimension lambda_dim, denoting the lambdas of the n-ellipsoid at end of all previous rollouts.
        rollout_ratio: 1 x T. A list (length up to T) of tensors, denoting the actual ratio for linear controller.
        internal_state_dim_num: size of internal state dimensions
        action_dim_num: size of action dimensions
        time_steps: time steps
        rollout_num: represents the number of rollouts
        env: the experiment environment, string
        write_to_csv: boolean
    Returns:
        None

    """

    save_data = {}
    total_graphs = internal_state_dim_num + 3
    width = 3
    height = math.ceil(total_graphs / width)

    mean_states = np.array(state_mean)
    var_states = np.array(state_var)
    rollouts = np.array(rollout)
    assert mean_states.shape[1] == internal_state_dim_num and var_states.shape[1] == internal_state_dim_num, \
        "--- Error: States dimensions do not match! ---"
    if rollout_actions is not None:
        actions = np.array(rollout_actions)
        assert actions.shape[1] == action_dim_num, "--- Error: Actions dimensions do not match! ---"

    if env == 'swingup':
        states_subtitles = [f'cos(\u03B8)', f'sin(\u03B8)', f'\u03B8_dot']
        actions_subtitles = ['torque']
        S_colors = ['green', 'firebrick', 'gold']
        S_legend = [f'\u03BB_cos(\u03B8)', f'\u03BB_sin(\u03B8)', f'\u03BB_\u03B8_dot']
    elif env == 'cartpole':
        states_subtitles = [f'x', f'x_dot', f'cos(\u03B8)', f'sin(\u03B8)', f'\u03B8_dot']
        actions_subtitles = ['force']
        S_colors = ['green', 'firebrick', 'gold', 'darkmagenta', 'navy']
        S_legend = [f'\u03BB_x', f'\u03BB_x_dot', f'\u03BB_cos(\u03B8)', f'\u03BB_sin(\u03B8)', f'\u03BB_\u03B8_dot']
    elif env == 'mountaincar':
        states_subtitles = [f'x', f'x_dot']
        actions_subtitles = ['force']
        S_colors = ['green', 'firebrick']
        S_legend = [f'\u03BB_x', f'\u03BB_x_dot']
    else:
        logger.error("--- Error: plot_single_rollout_cycle() env incorrect! ---")
    assert len(states_subtitles) == internal_state_dim_num, "--- Error: Change states_subtitles! ---"
    assert len(actions_subtitles) == action_dim_num, "--- Error: Change actions_subtitles! ---"

    plt.style.use('seaborn-darkgrid')

    fig, axs = plt.subplots(height, width, figsize=(9, height * 3), constrained_layout=True)
    fig.suptitle(f'Rollout {rollout_num}', fontsize=16)
    for i in range(total_graphs):
        cur_graph_pos_i, cur_graph_pos_j = i // width, i % width
        plot_states = i < internal_state_dim_num
        plot_S = i == total_graphs - 2 and all_S is not None
        plot_ratio = i == total_graphs - 3 and rollout_ratio is not None
        plot_reward = i == total_graphs - 1 and all_rewards is not None
        cur_axis = axs[cur_graph_pos_i, cur_graph_pos_j]

        # Plotting the state variables across timesteps
        if plot_states:
            y = mean_states[:, i]
            yerr = var_states[:, i]
            cur_axis.plot(np.arange(time_steps), y, color='royalblue', label='Predict')
            cur_axis.fill_between(np.arange(time_steps), y - yerr, y + yerr, alpha=0.5, facecolor='royalblue',
                                  label=f'\u00B1\u03C3_Predict')
            early_termination_time_steps = rollouts.shape[1]
            cur_axis.plot(np.arange(early_termination_time_steps), rollouts[0, :, i], color='darkorange',
                          label='Actual')
            cur_axis.set_xlabel('Timesteps')
            cur_axis.legend()
            cur_axis.set_title(f'State: {states_subtitles[i]}')

            save_data[f'states_mean_{i}'] = y
            save_data[f'states_err_{i}'] = yerr

        # # Plotting the actions across timesteps
        # if plot_actions:
        #     # Plot one of the M subplots for actions
        #     j = i - internal_state_dim_num
        #     cur_axis.plot(np.arange(time_steps), actions[:, j])
        #     cur_axis.set_title(f'Action: {actions_subtitles[j]}')

        # Plotting the ratio across timesteps
        if plot_ratio:
            cur_axis.plot(np.arange(len(rollout_ratio)), rollout_ratio, color='darkorange', label='Actual')
            cur_axis.set_xlim(0, time_steps)
            cur_axis.set_xlabel('Timesteps')
            cur_axis.legend()
            cur_axis.set_title(f'Linear Controller Ratio')

            save_data['ratio'] = rollout_ratio

        # Plotting the S across rollouts
        if plot_S:
            S_dim = len(all_S[0])
            for j in range(S_dim):
                cur_axis.plot(np.arange(rollout_num + 1), all_S[:, j], color=S_colors[j], label=S_legend[j])
            cur_axis.set_xlabel('Epochs')
            cur_axis.legend()
            cur_axis.set_title(f'\u039B of n-Ellipsoid')

            for j in range(S_dim):
                save_data[f'S_{j}'] = all_S[:, j]

        # Plotting the rewards across rollouts
        if plot_reward:
            cur_axis.plot(np.arange(rollout_num + 1), all_rewards, label='Predicted')
            cur_axis.set_xlabel('Epochs')
            cur_axis.legend()
            cur_axis.set_title(f'Reward')

            save_data[f'rewards'] = all_rewards

    fig.show()

    # Save data to csv
    if write_to_csv:
        df = pd.DataFrame(dict([(k, pd.Series(v)) for k, v in save_data.items()]), columns=save_data.keys())
        df.to_csv(f'save_data_epoch{rollout_num}.csv', index=False, header=True)
        print(f'ITERATION {rollout_num} saved to csv.')


def plot_stability_analysis_chart(percentage_stable: List[np.ndarray], noise_value: List[np.ndarray], names: List[str],
                                  envs: List[str]):
    """

    Args:
        percentage_stable: E x C x N. A list (length E) of numpy array of dimension (C x N), denoting the percentage stable for all controllers in all environments.
        noise_value: 1 x N. A list (dimension N) of percentage noises.
        names: 1 x C. A list (length C), denoting the names of the controllers.
        envs: 1 x E. A list (length E) denoting the names of the environments.
    Returns:
        None

    """
    total_graphs = len(percentage_stable)
    colors = ['royalblue', 'orange', 'green']

    plt.style.use('seaborn-darkgrid')

    fig, axs = plt.subplots(1, 3, figsize=(9, 3), constrained_layout=True)
    # axs.xaxis.set_major_formatter(mtick.PercentFormatter(5.0))
    # axs.yaxis.set_major_formatter(PercentFormatter())

    for i in range(total_graphs):
        cur_axis = axs[i]
        x = noise_value
        for j in range(len(percentage_stable[i])):
            y = percentage_stable[i][j] * 100
            cur_axis.plot(x, y, color=colors[j % len(colors)], label=names[j], linestyle='-', marker='o')
        cur_axis.set_ylim(50, 105)
        cur_axis.set_xlabel('Noise %')
        cur_axis.set_ylabel('% trials stable')
        cur_axis.legend()
        cur_axis.set_title(envs[i])

    plt.show()


def plot_interaction_barchart(y_extended, y_pilco):
    # width of the bars
    barWidth = 0.2

    # The x position of bars
    r1 = np.arange(len(y_pilco))
    r2 = [x + barWidth for x in r1]

    plt.style.use('seaborn-darkgrid')

    # Create the bars
    plt.bar(r1, y_pilco, width=barWidth, color='royalblue', capsize=15, label='RBF Controller (PILCO)')
    plt.bar(r2, y_extended, width=barWidth, color='orange', capsize=15, label='Extended RBF controller')

    # general layout
    plt.xticks([r + barWidth / 2 for r in range(len(y_extended))], ['Swing-up pendulum', 'Cartpole', 'Mountain car'])
    plt.ylabel('Interaction time (s)')
    plt.legend()

    # Show graphic
    plt.show()


if __name__ == "__main__":
    pass
