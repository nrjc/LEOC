from typing import List, Tuple
import math
import numpy as np
import pandas as pd
import csv
from matplotlib import pyplot as plt
from gym import logger

from tf_agents.trajectories.trajectory import Trajectory
import tensorflow as tf


# This class plots different graphs for a single epoch from a list of trajectories generated by eval
class EpochPlotter(object):
    def __init__(self, trajectories: List[Trajectory], plot):
        self.trajectories = trajectories
        self.states = trajectories
        self.rewards = trajectories
        self.ratio = trajectories
        self.timesteps = trajectories
        self.early_termination_timesteps = len(self.states)
        plt.style.use('seaborn-darkgrid')

    def traj2theta(self, trajectories: Trajectory) -> np.ndarray:
        """
        Input:
            trajectories: trajectories from eval
        Output:
            np.ndarray of states
        """
        sin_theta, cos_theta = trajectories, trajectories
        tan_theta = sin_theta / cos_theta
        theta = tf.math.atan(tan_theta)
        return theta

    def traj2metrics(self, trajectories: Trajectory, target: List[float], stability_bound: float) \
            -> Tuple[float, int, int]:
        """
        Input:
            trajectories: trajectories from eval
        Output:
            np.ndarray of the control theory metrics
        """
        traj = np.array(trajectories)
        peak_overshot = max(traj) - target
        rising_time = traj.index(max(traj))

        traj_reverse = traj[::-1]
        upper_stability_bound, lower_stability_bound = target + stability_bound, target - stability_bound
        settling_time = np.argmax(lower_stability_bound < traj_reverse < upper_stability_bound)
        settling_time = len(traj_reverse) - settling_time

        return (peak_overshot, rising_time, settling_time)

    def plot_theta(self, subplot, x, y, x_label, y_label):
        # Plot theta
        subplot.plot(x, y, color='darkorange', label=y_label)
        subplot.set_xlabel(x_label)
        subplot.legend()
        subplot.set_title(f'\u03B8')

    def plot_rollout(self):
        # Plot theta and linear ratio from PILCO

        realise_theta = self.traj2theta(realise_sin_theta, realise_cos_theta)
        predict_theta = self.traj2theta(predict_sin_theta, predict_cos_theta)
        predict_sin_plus_sd, predict_cos_plus_sd = self.trajectories, self.trajectories
        predict_theta_plus_sd = convert_theta(predict_sin_plus_sd, predict_cos_plus_sd)
        predict_sin_minus_sd, predict_cos_minus_sd = self.trajectories, self.trajectories
        predict_theta_minus_sd = convert_theta(predict_sin_minus_sd, predict_cos_minus_sd)

        fig, axs = plt.subplots(1, 2, figsize=(9, 3), constrained_layout=True)

        # Plot theta
        self.plot_theta(axs[0], x=np.arange(self.early_termination_timesteps), y=realise_theta,
                        x_label='Timesteps', y_label='Actual')
        axs[0].plot(np.arange(self.timesteps), predict_theta, color='royalblue', label='Predict')
        axs[0].fill_between(np.arange(self.timesteps), predict_theta_minus_sd, predict_theta_plus_sd, alpha=0.5,
                            facecolor='royalblue', label=f'\u00B1\u03C3_Predict')


        # Plot linear ratio
        axs[1].plot(np.arange(len(self.ratio)), self.ratio, color='darkorange', label='Actual')
        axs[1].set_xlim(0, self.timesteps)
        axs[1].set_xlabel('Timesteps')
        axs[1].legend()
        axs[1].set_title(f'Linear Controller Ratio')

        fig.show()

    def plot_metrics(self):
        pass


# This class plots learning curves for the entire training session from a list of np.arrays
class EntireTrainingPlotter(object):
    def __init__(self, rewards: List[np.ndarray]):
        self.rewards = rewards

    def plot_rewards(self):
        pass


def plot_single_rollout_cycle(state_mean: List[np.ndarray], state_var: List[np.ndarray],
                              rollout: List[List[np.ndarray]], rollout_actions: List[np.ndarray],
                              all_rewards: List[np.ndarray], all_S: List[np.ndarray], rollout_ratio: List[np.ndarray],
                              internal_state_dim_num: int, action_dim_num: int,
                              time_steps: int, rollout_num: int, env='swing up', write_to_csv=False):
    """

    Args:
        state_mean: T x N. A list (length T) of numpy array of dimension (N), denoting the predicted means at each time step.
        state_var: T x N. A list (length T) of numpy array of dimension (N), denoting the variance at each time step.
        rollout: S x T x N. A list (length S) of list (length T) of numpy array of dimension (N), denoting the observed parameter state.
        rollout_action: T x M. A list (length T) of numpy array of dimension (M), denoting the actions taken by rollout controller.
        all_rewards: 1 x N. A list (length N) of tensors, denoting the reward at the end of all previous rollouts.
        all_S: N x lambda_dim.  A list (length N) of tensors of dimension lambda_dim, denoting the lambdas of the n-ellipsoid at end of all previous rollouts.
        rollout_ratio: 1 x T. A list (length up to T) of tensors, denoting the actual ratio for linear controller.
        internal_state_dim_num: size of internal state dimensions
        action_dim_num: size of action dimensions
        time_steps: time steps
        rollout_num: represents the number of rollouts
        env: the experiment environment, string
        write_to_csv: boolean
    Returns:
        None

    """

    save_data = {}
    total_graphs = internal_state_dim_num + 3
    width = 3
    height = math.ceil(total_graphs / width)

    mean_states = np.array(state_mean)
    var_states = np.array(state_var)
    rollouts = np.array(rollout)
    assert mean_states.shape[1] == internal_state_dim_num and var_states.shape[1] == internal_state_dim_num, \
        "--- Error: States dimensions do not match! ---"
    if rollout_actions is not None:
        actions = np.array(rollout_actions)
        assert actions.shape[1] == action_dim_num, "--- Error: Actions dimensions do not match! ---"

    if env == 'swingup':
        states_subtitles = [f'cos(\u03B8)', f'sin(\u03B8)', f'\u03B8_dot']
        actions_subtitles = ['torque']
        S_colors = ['green', 'firebrick', 'gold']
        S_legend = [f'\u03BB_cos(\u03B8)', f'\u03BB_sin(\u03B8)', f'\u03BB_\u03B8_dot']
    elif env == 'cartpole':
        states_subtitles = [f'x', f'x_dot', f'cos(\u03B8)', f'sin(\u03B8)', f'\u03B8_dot']
        actions_subtitles = ['force']
        S_colors = ['green', 'firebrick', 'gold', 'darkmagenta', 'navy']
        S_legend = [f'\u03BB_x', f'\u03BB_x_dot', f'\u03BB_cos(\u03B8)', f'\u03BB_sin(\u03B8)', f'\u03BB_\u03B8_dot']
    elif env == 'mountaincar':
        states_subtitles = [f'x', f'x_dot']
        actions_subtitles = ['force']
        S_colors = ['green', 'firebrick']
        S_legend = [f'\u03BB_x', f'\u03BB_x_dot']
    else:
        logger.error("--- Error: plot_single_rollout_cycle() env incorrect! ---")
    assert len(states_subtitles) == internal_state_dim_num, "--- Error: Change states_subtitles! ---"
    assert len(actions_subtitles) == action_dim_num, "--- Error: Change actions_subtitles! ---"

    plt.style.use('seaborn-darkgrid')

    fig, axs = plt.subplots(height, width, figsize=(9, height * 3), constrained_layout=True)
    fig.suptitle(f'Rollout {rollout_num}', fontsize=16)
    for i in range(total_graphs):
        cur_graph_pos_i, cur_graph_pos_j = i // width, i % width
        plot_states = i < internal_state_dim_num
        plot_S = i == total_graphs - 2 and all_S is not None
        plot_ratio = i == total_graphs - 3 and rollout_ratio is not None
        plot_reward = i == total_graphs - 1 and all_rewards is not None
        cur_axis = axs[cur_graph_pos_i, cur_graph_pos_j]

        # Plotting the state variables across timesteps
        if plot_states:
            y = mean_states[:, i]
            yerr = var_states[:, i]
            cur_axis.plot(np.arange(time_steps), y, color='royalblue', label='Predict')
            cur_axis.fill_between(np.arange(time_steps), y - yerr, y + yerr, alpha=0.5, facecolor='royalblue',
                                  label=f'\u00B1\u03C3_Predict')
            early_termination_time_steps = rollouts.shape[1]
            cur_axis.plot(np.arange(early_termination_time_steps), rollouts[0, :, i], color='darkorange',
                          label='Actual')
            cur_axis.set_xlabel('Timesteps')
            cur_axis.legend()
            cur_axis.set_title(f'State: {states_subtitles[i]}')

            save_data[f'states_mean_{i}'] = y
            save_data[f'states_err_{i}'] = yerr

        # # Plotting the actions across timesteps
        # if plot_actions:
        #     # Plot one of the M subplots for actions
        #     j = i - internal_state_dim_num
        #     cur_axis.plot(np.arange(time_steps), actions[:, j])
        #     cur_axis.set_title(f'Action: {actions_subtitles[j]}')

        # Plotting the ratio across timesteps
        if plot_ratio:
            cur_axis.plot(np.arange(len(rollout_ratio)), rollout_ratio, color='darkorange', label='Actual')
            cur_axis.set_xlim(0, time_steps)
            cur_axis.set_xlabel('Timesteps')
            cur_axis.legend()
            cur_axis.set_title(f'Linear Controller Ratio')

            save_data['ratio'] = rollout_ratio

        # Plotting the S across rollouts
        if plot_S:
            S_dim = len(all_S[0])
            for j in range(S_dim):
                cur_axis.plot(np.arange(rollout_num + 1), all_S[:, j], color=S_colors[j], label=S_legend[j])
            cur_axis.set_xlabel('Epochs')
            cur_axis.legend()
            cur_axis.set_title(f'\u039B of n-Ellipsoid')

            for j in range(S_dim):
                save_data[f'S_{j}'] = all_S[:, j]

        # Plotting the rewards across rollouts
        if plot_reward:
            cur_axis.plot(np.arange(rollout_num + 1), all_rewards, label='Predicted')
            cur_axis.set_xlabel('Epochs')
            cur_axis.legend()
            cur_axis.set_title(f'Reward')

            save_data[f'rewards'] = all_rewards

    fig.show()

    # Save data to csv
    if write_to_csv:
        df = pd.DataFrame(dict([(k, pd.Series(v)) for k, v in save_data.items()]), columns=save_data.keys())
        df.to_csv(f'save_data_epoch{rollout_num}.csv', index=False, header=True)
        print(f'ITERATION {rollout_num} saved to csv.')


def plot_stability_analysis_chart(percentage_stable: List[np.ndarray], noise_value: List[np.ndarray], names: List[str],
                                  envs: List[str]):
    """

    Args:
        percentage_stable: E x C x N. A list (length E) of numpy array of dimension (C x N), denoting the percentage stable for all controllers in all environments.
        noise_value: 1 x N. A list (dimension N) of percentage noises.
        names: 1 x C. A list (length C), denoting the names of the controllers.
        envs: 1 x E. A list (length E) denoting the names of the environments.
    Returns:
        None

    """
    total_graphs = len(percentage_stable)
    colors = ['royalblue', 'orange', 'green']

    plt.style.use('seaborn-darkgrid')

    fig, axs = plt.subplots(1, 3, figsize=(9, 3), constrained_layout=True)
    # axs.xaxis.set_major_formatter(mtick.PercentFormatter(5.0))
    # axs.yaxis.set_major_formatter(PercentFormatter())

    for i in range(total_graphs):
        cur_axis = axs[i]
        x = noise_value
        for j in range(len(percentage_stable[i])):
            y = percentage_stable[i][j] * 100
            cur_axis.plot(x, y, color=colors[j % len(colors)], label=names[j], linestyle='-', marker='o')
        cur_axis.set_ylim(50, 105)
        cur_axis.set_xlabel('Noise %')
        cur_axis.set_ylabel('% trials stable')
        cur_axis.legend()
        cur_axis.set_title(envs[i])

    plt.show()


def plot_interaction_barchart(y_extended, y_pilco):
    # width of the bars
    barWidth = 0.2

    # The x position of bars
    r1 = np.arange(len(y_pilco))
    r2 = [x + barWidth for x in r1]

    plt.style.use('seaborn-darkgrid')

    # Create the bars
    plt.bar(r1, y_pilco, width=barWidth, color='royalblue', capsize=15, label='RBF Controller (PILCO)')
    plt.bar(r2, y_extended, width=barWidth, color='orange', capsize=15, label='Extended RBF controller')

    # general layout
    plt.xticks([r + barWidth / 2 for r in range(len(y_extended))], ['Swing-up pendulum', 'Cartpole', 'Mountain car'])
    plt.ylabel('Interaction time (s)')
    plt.legend()

    # Show graphic
    plt.show()


if __name__ == "__main__":
    pass